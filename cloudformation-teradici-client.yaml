AWSTemplateFormatVersion: 2010-09-09

Resources:
  CognitoIdentityPool:
    Type: AWS::Cognito::IdentityPool
    Properties:
      IdentityPoolName: "WorkSpacesPortalIdentityPool"
      AllowUnauthenticatedIdentities: true
  CognitoIdentityPoolAttachment:
    Type: AWS::Cognito::IdentityPoolRoleAttachment
    Properties:
      IdentityPoolId: !Ref CognitoIdentityPool
      Roles: 
        "unauthenticated": !GetAtt UnauthenticatedCognitoIdentityPoolRole.Arn
   
  RestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: "getWorkSpacesInfoForUser"
  BuildURIResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt RestApi.RootResourceId
      PathPart: "build-uri"
      RestApiId: !Ref RestApi
  APIGatewayPOSTMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: "AWS_IAM"
      HttpMethod: "POST"
      Integration:
        IntegrationHttpMethod: "POST"
        Type: "AWS"
        Uri: !Sub
          - "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${lambdaArn}/invocations"
          - lambdaArn: !GetAtt "getWorkSpacesInfoForUserFunction.Arn"
        IntegrationResponses:
          - ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            StatusCode: '200'
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - ResponseModels:
            application/json: Empty
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true
          StatusCode: '200'
      OperationName: "build-uri"
      ResourceId: !Ref BuildURIResource
      RestApiId: !Ref RestApi

  APIGatewayOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "OPTIONS"
      Integration:
        Type: "MOCK"
        RequestTemplates:
          "application/json": "{\n    \"statusCode\": 200 \n}"
        IntegrationResponses:
          - ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            StatusCode: '200'
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - ResponseModels:
            application/json: Empty
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true
          StatusCode: '200'
      OperationName: "build-uri"
      ResourceId: !Ref BuildURIResource
      RestApiId: !Ref RestApi
  APIGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - "APIGatewayPOSTMethod"
    Properties:
      RestApiId: !Ref RestApi
      StageName: "dev"
     
  ConfigLambdaPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
    - RestApi
    - getWorkSpacesInfoForUserFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref getWorkSpacesInfoForUserFunction
      Principal: apigateway.amazonaws.com
      
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/AmazonWorkSpacesAdmin"
        - "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        - "arn:aws:iam::aws:policy/AWSDirectoryServiceReadOnlyAccess"
        
  UnauthenticatedCognitoIdentityPoolRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Federated:
              - "cognito-identity.amazonaws.com"
          Action:
            - "sts:AssumeRoleWithWebIdentity"
      Path: "/"
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/AmazonAPIGatewayInvokeFullAccess"

  getWorkSpacesInfoForUserFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Timeout: 10
      Environment:
        Variables:
          "PCM_URL_TAG": "PCM"
          "NAME_TAG": "NAME"
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: !Sub |
            import json
            import boto3
            import sys
            import os

            client = boto3.client('workspaces', region_name='${AWS::Region}')
            ds_client = boto3.client('ds', region_name='${AWS::Region}')

            def build_error_response(message):
                return {
                    "statusCode": 500,
                    "errorMessage" : message
                } 
                
            def construct_workspaces_uri(username, directoryID, regCode):
                uri = "workspaces://"+username+"@"+regCode
                #uri = "workspaces://"+username+"@"+regCode

                return uri
                
            # In this function, we return the PCM URL tag for a Directory (given its ID)
            # This may be useful to include in the response if you've deployed Teradici PCM
            # for use with Teradici Zero Clients.
            def get_pcm_url_for_directory(directoryID):

                tag_name = os.environ['PCM_URL_TAG']    

                tags = ds_client.list_tags_for_resource(
                    ResourceId=directoryID
                )

                if(len(tags["Tags"])<1):
                    return "";

                # Get first key, value pair which matches our Key value
                pcm_tag = next((tag for tag in tags["Tags"] if tag.get('Key') == tag_name), None)

                # If the PCM tag has not been set, pcm_tag will be empty. Checking that here.
                if pcm_tag:
                    return pcm_tag["Value"]
                else:
                    return ""

            # In this function, we return the NAME tag for a Directory (given its ID)
            # This may be useful to include in the response if there are multiple directories
            # which contain a WorkSpace for the user. This will make it easier for the user to 
            # understand what each directory is and which WorkSpace to pick.

            def get_name_tag_for_directory(directoryID):

                tag_name = os.environ['NAME_TAG']    

                tags = ds_client.list_tags_for_resource(
                    ResourceId=directoryID
                )

                if(len(tags["Tags"])<1):
                    return "";

                # Get first key, value pair which matches our Key value
                name = next((tag for tag in tags["Tags"] if tag.get('Key') == tag_name), None)

                # If the NAME tag has not been set, it will be empty. Checking that here.
                if name:
                    return name["Value"]
                else:
                    return ""


            def get_workspaces_info_for_user(username, list_of_directories):

            # In this function, we return the Directory ID, Reg Code and PCM URL for each
            # Directory that has a workspace for the user

                workspaces_info_for_user = [];

                for directory in list_of_directories:
                    directoryID = directory["DirectoryId"]
                    try:
                        print("Checking directory " + directoryID)
                        response = client.describe_workspaces(
                            DirectoryId=directoryID,
                            UserName=username
                        )

                        if(len(response["Workspaces"]) > 0):
                            print("Found a workspace!")

                            regCode = directory["RegistrationCode"]
                            pcm_url = get_pcm_url_for_directory(directoryID)
                            name_tag = get_name_tag_for_directory(directoryID)
                            uri = construct_workspaces_uri(username, directoryID, regCode)
                    
                            workspaces_info_for_user.append({'directoryID':directoryID,'regCode':regCode, 
                                                            'pcm_url':pcm_url, 'name':name_tag, 'uri':uri })
                        else:
                            print("No WorkSpaces for user "+username+" in directory " + directoryID)
                    except:
                        print("There was an error when calling directory " + directoryID)
                        print("Unexpected error:", sys.exc_info()[0])

                return workspaces_info_for_user

            def lambda_handler(event, context):
                workspaces_info_for_user = [];
                username = event["username"]
    
                if(username == ""):
                    return build_error_response("Provided username is invalid.") 

                list_of_directories = client.describe_workspace_directories()["Directories"]

                if(len(list_of_directories) < 1):
                    return build_error_response("No registered Directories found in your account.")

                directories = get_workspaces_info_for_user(username,list_of_directories)
    
                if(len(directories) < 1):
                    return build_error_response("No WorkSpaces Found for user "+username)

                return {
                    "statusCode": 200,
                    "directories": directories
                }

      Runtime: python3.6
Outputs:
  apiGatewayInvokeURL:
    Value: !Sub "https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/dev"
  CognitoIdentityPoolId:
    Value: !Ref CognitoIdentityPool