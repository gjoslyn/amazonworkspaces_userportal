AWSTemplateFormatVersion: 2010-09-09

Parameters:
  BucketName:
    Description: Name of the new S3 bucket where the website will be deployed.
    Type: String
    MinLength: 3
    MaxLength: 63

Resources:

  CognitoIdentityPool:
    Type: AWS::Cognito::IdentityPool
    Properties:
      IdentityPoolName: "WorkSpacesPortalIdentityPool"
      AllowUnauthenticatedIdentities: true
  CognitoIdentityPoolAttachment:
    Type: AWS::Cognito::IdentityPoolRoleAttachment
    Properties:
      IdentityPoolId: !Ref CognitoIdentityPool
      Roles: 
        "unauthenticated": !GetAtt UnauthenticatedCognitoIdentityPoolRole.Arn
   
  RestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: "constructURIForWorkSpaceUserAPI"
  BuildURIResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt RestApi.RootResourceId
      PathPart: "build-uri"
      RestApiId: !Ref RestApi
  APIGatewayPOSTMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: "AWS_IAM"
      HttpMethod: "POST"
      Integration:
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub
          - "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${lambdaArn}/invocations"
          - lambdaArn: !GetAtt "constructWorkSpacesURIForUserFunction.Arn"
        IntegrationResponses:
          - ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            StatusCode: '200'
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - ResponseModels:
            application/json: Empty
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true
          StatusCode: '200'
      OperationName: "build-uri"
      ResourceId: !Ref BuildURIResource
      RestApiId: !Ref RestApi

  APIGatewayOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: "AWS_IAM"
      HttpMethod: "OPTIONS"
      Integration:
        Type: "MOCK"
        IntegrationResponses:
          - ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            StatusCode: '200'
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - ResponseModels:
            application/json: Empty
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true
          StatusCode: '200'
      OperationName: "build-uri"
      ResourceId: !Ref BuildURIResource
      RestApiId: !Ref RestApi
  APIGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - "APIGatewayPOSTMethod"
    Properties:
      RestApiId: !Ref RestApi
      StageName: "dev"

  DeployWebsiteFunctionLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/AmazonS3FullAccess"
        - "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        - "arn:aws:iam::aws:policy/AWSDirectoryServiceReadOnlyAccess"

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/AmazonWorkSpacesAdmin"
        - "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  UnauthenticatedCognitoIdentityPoolRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Federated:
              - "cognito-identity.amazonaws.com"
          Action:
            - "sts:AssumeRoleWithWebIdentity"
      Path: "/"
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/AmazonAPIGatewayInvokeFullAccess"

  DeployWebsiteFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt DeployWebsiteFunctionLambdaRole.Arn
      Timeout: 30
      Environment: 
        Variables:
          "IDENTITY_POOL": !Ref CognitoIdentityPool
          "REGION": !Ref AWS::Region
          "API_GW_URL": !Sub "https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/dev"
          "BUCKET_NAME": !Ref BucketName
      Code:
        ZipFile: !Sub |
            import json
            import boto3
            import inspect
            import os
            import urllib.request
            import mimetypes


            def lambda_handler(event, context):
                s3 = boto3.resource('s3')

                BUCKET_NAME = os.environ['BUCKET_NAME']
                IDENTITY_POOL = os.environ['IDENTITY_POOL']
                REGION = os.environ['REGION']
                API_GW_URL = os.environ['API_GW_URL']

                bucket = s3.Bucket(BUCKET_NAME)

                configData = inspect.cleandoc(""" var configs = {
                                     'region' : '"""+ REGION +"""',
                                     'identityPool': '"""+ IDENTITY_POOL +"""',
                                     'APIGatewayUrl': '"""+ API_GW_URL +"""'
                                 }""")

                with open('/tmp/configs.js', 'w') as data:
                    data.write(configData)

                key = 'configs.js'
                bucket.upload_file('/tmp/configs.js', key)

                files = ['index.html',
                         'scripts.js',
                         'sign4.js',
                         'styles.css',
                         'underscore.js',
                         'favicon.ico',
                         'aws-workspaces-logo.png',
                         'launch.php'
                         ]

                for file in files:
                    url = "https://raw.githubusercontent.com/sdebrosse/amazonworkspaces_userportal/teradici_client/website/"+file
                    print("Downloaded "+url)

                    response = urllib.request.urlopen(url)

                    print("Downloaded "+url)
        
                    with open('/tmp/'+file, 'wb') as data:
                        data.write(response.read())
            
                    mimetype, _ = mimetypes.guess_type('/tmp/'+file)
                    bucket.upload_file('/tmp/'+file, file, ExtraArgs={'ContentType': mimetype})

                # TODO implement
                return {
                    'statusCode': 200,
                    'body': json.dumps('Finished deploying website to S3')
                }


      Runtime: python3.6

        
  retrievePCMEndpointForUser:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: !Sub |
            import json
            import boto3
            import sys
            import os

            client = boto3.client('workspaces', region_name='us-east-1')
            ds_client = boto3.client('ds', region_name='us-east-1')

            #In this function, we return the PCM URL tag for a Directory (given its ID)
            def get_pcm_url_for_directory(directoryID):

                tag_name = os.environ['PCM_URL_TAG_NAME']    
    
                tags = ds_client.list_tags_for_resource(
                    ResourceId=directoryID
                )
    
                if(len(tags["Tags"])<1):
                    return "";
    
                # Get first key, value pair which matches our Key value
                pcm_tag = next((tag for tag in tags["Tags"] if tag.get('Key') == tag_name), None)
    
                print("URL is "+pcm_tag["Value"])
    
                return pcm_tag["Value"]
    
    
            def get_dir_id_and_regcode_for_user(username, list_of_directories):

            # In this function, we return the first directory ID/reg code that has a workspace for the user

                for directory in list_of_directories:
                    try:
                        print("Checking directory "+directory[0])
                        response = client.describe_workspaces(
                            DirectoryId=directory[0],
                            UserName=username
                        )
                        #print(response)
                        #print(len(response["Workspaces"]))
                        if(len(response["Workspaces"]) > 0):
                            print("Found a workspace!")
                            return [directory[0], directory[1]]
                        else:
                            print("No WorkSpaces for user "+username+" in directory " + directory[0])
                    except:
                        print("There was an error when calling directory " + directory[0])
                        print("Unexpected error:", sys.exc_info()[0])

                return []

            def get_list_of_workspace_directories():

                # Get a list of all workspaces in the directory
                response = client.describe_workspace_directories()
                directories = []

                for directory in response["Directories"]:
                    directoryID = directory["DirectoryId"]
                    regCode = directory["RegistrationCode"]

                    #Appends a tuple to the directories list. Each tuple contains the directory ID and reg code.
                    directories.append([directoryID,regCode])

                #print ("Directories found: "+str(len(directories)))
                return directories


            def lambda_handler(event, context):
                # TODO implement
    
                username = event["username"]

                list_of_directories = get_list_of_workspace_directories()
    
                if(len(list_of_directories) < 1):
                    return {
                        "statusCode": 500,
                        "errorMessage" : "No registered Directories found in your account."
                    } 
    
                users_directory = get_dir_id_and_regcode_for_user(username,list_of_directories)

                if(len(users_directory) < 1):
                    return {
                        "statusCode": 500,
                        "errorMessage" : "No WorkSpaces Found for user "+username
                    } 
    
                users_directory = get_dir_id_and_regcode_for_user(username,list_of_directories)
                directoryID = users_directory[0];
                regCode = users_directory[1];
    
                print("Directory for user "+username+" is " + directoryID)
                print("Reg Code for user "+username+" is " + regCode)
    
                pcm_url = get_pcm_url_for_directory(directoryID)
    
                if(pcm_url == ""):
                    return {
                        "statusCode": 500,
                        "errorMessage" : "PCM tag not set for directory "+directoryID+". Please inform WorkSpaces administrator."
                    } 
    
                return {
                    "statusCode": 200,
                    "pcm_url": pcm_url
                }


      Runtime: python3.6
Outputs:
  apiGatewayInvokeURL:
    Value: !Sub "https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/dev"
  CognitoIdentityPoolId:
    Value: !Ref CognitoIdentityPool
  RootResourceId:
    Value: !GetAtt RestApi.RootResourceId
